---
title: "Homework 4, Prioritizing Potential Aquaculture"
author: "Eva Newby"
format: html
execute: 
  warning: false
  error: false
editor: visual
editor_options: 
  chunk_output_type: console
---

#### Link to Homework 4 Description: https://eds-223-geospatial.github.io/assignments/HW4.html

Species of choice- Common cuttlefish (Sepia officinalis) https://www.sealifebase.ca/summary/Sepia-officinalis.html

```{r}
# Load Packages
library(tidyverse)
library(stars)
library(tmap)
library(sf)
library(here)
library(terra)
library(kableExtra)
```

## Prepare Data

```{r}
# Read in shapefile for the West Coast EEZ
wc_regions <- vect(here("data", "wc_regions_clean[1].shp"))%>%
  terra::project("EPSG:4326")
```

```{r}
# Read in bathymetry raster
depth <- terra::rast(here("data", "depth[1].tif"))%>%
  terra::project("EPSG:4326")
```

```{r}
# Read in SST rasters
# Create list of all SST .tif files 
sst_path = here("data")

sst_files <- list.files(sst_path, 
                        pattern = glob2rx("*average_annual_sst_*.tif$"),
                        full.names = TRUE)
# Create a raster stack 
sst <- terra::rast(sst_files)%>%
  terra::project("EPSG:4326")
```

```{r}
# Check CRS' and transform to match
print(st_crs(depth))
print(st_crs(wc_regions))
print(st_crs(sst))
```

## Process data

```{r}
# View rasters to see what we are working with
plot(sst)
plot(wc_regions)
plot(depth)
```

```{r}
# Find the mean SST from 2008-2012 (e.g. create single raster of average SST)
avg_sst <- mean(sst)

# Plot to check
plot(avg_sst)
```

```{r}
# Convert average SST from Kelvin to Celsius (hint: subtract by 273.15)
avg_sst_c <- avg_sst - 273.15

# Verify update
avg_sst_c
```

```{r}
# Crop depth raster to match the extent of the SST raster
depth <- crop(x = depth, y = avg_sst_c)

# View the plot
plot(depth)
```

```{r}
# note: the resolutions of the SST and depth data do not match
# Resample the depth data to match the resolution of the SST data using the nearest neighbor approach
depth <- resample(depth,
                  avg_sst_c,
                  method = "near")
                  
```

```{r}
# Check that the depth and SST match in resolution, extent, and coordinate reference system (hint: can the rasters be stacked?)
cat("Do the extents match?",
    terra::ext(avg_sst_c) == terra::ext(depth),
    "\nDo the resolutions match?",
    terra::res(avg_sst_c) == terra::res(depth),
    "\n Do the CRS' match?",
    terra::crs(avg_sst_c) == terra::crs(depth))
```

### Find suitable locations for Oysters

```{r}
# reclassify SST and depth data into locations that are suitable for oysters (hint: set suitable values to 1 and unsuitable values to 0)
sst_reclass <- matrix(c(-Inf, 11, 0,
                        11, 30, 1,
                        30, Inf, 0),
                      ncol = 3,
                      byrow= TRUE)

depth_reclass <- matrix(c(-Inf, 0, 0,
                        0, 70, 1,
                        70, Inf, 0),
                      ncol = 3,
                      byrow= TRUE)
```

```{r}
# Apply matrices to reclassify depth and sst rasters for Oyster suitability
optimal_sst <- classify(avg_sst_c,
                        rcl = sst_reclass)

optimal_depth <- classify(depth,
                        rcl = depth_reclass)
```

```{r}
# Find locations that satisfy both SST and depth conditions
# HINT: The SST and depth rasters should now identify the suitability of locations as 0 or 1. To find locations that have both suitable temperature and depth, you can use map algebra. One idea is to multiply the values in each raster cell, using the lapp() function.

optimal_fun <- function(sst, depth) {
  sst * depth
    }

optimal_locs <- lapp(c(optimal_sst, optimal_depth), fun = optimal_fun)

# Plot optimal locations
plot(optimal_locs)
```

### Determine the most suitable EEZ for Oysters

```{r}
# Select suitable cells within West Coast EEZs, using `mask()` within cellSize()

optimal_locs_mask <- cellSize(x = optimal_locs, # area of cells
                              mask = TRUE,
                              unit = 'km',
                              transform = TRUE)

# Plot to view the mask
plot(optimal_locs_mask)
  
```

```{r}
# Find the total suitable area within each EEZ (hint: it might be helpful to rasterize the EEZ data)

# Rasterize wc_regions data
eez_raster <- rasterize(x = wc_regions,
                        y = optimal_locs,
                        field = 'rgn')

# View raster to confirm change
plot(eez_raster)
```

```{r}
# Total suitable area can be found with zonal function from terra. 
optimal_locs_total <- zonal(x = optimal_locs_mask,
                           z = eez_raster,
                           fun = "sum",
                           na.rm = TRUE)
```

```{r}
# Present outputs in a table
optimal_order <- optimal_locs_total[order(optimal_locs_total$area, decreasing = TRUE),]

optimal_order %>% 
  kable(caption = "Total Suitable Area Within Each EEZ")
```

#### Visualize our results
```{r}
plot_1 <- tm_shape()
```


```{r}
# Visualize results
# making centroids
#state_centroids <- st_centroid(west_coast)

# making total suitable area plot
plot_1 <- ggplot() +
 # geom_sf(data = west_coast, # plotting base map layer
 #         fill = "gainsboro") +
  #geom_sf_text(data = state_centroids, 
   #            aes(label = stusps), # adding state abbreviations at centroids
    #           size = 2.5) +
  geom_sf(data = optimal_locs_total,
          aes(fill = area)) +
  scale_fill_distiller(palette = "Blues",
                       direction = 1) + # reverse default color order
  coord_sf() + # to follow our coordinate system, not Cartesian
  ggspatial::annotation_scale(plot_unit = "km",
                              location = "bl", # bottom left corner
                              pad_y = unit(0.01, "cm")) +# from function documentation, used to move the bar closer to the y-axis
                                
  annotation_north_arrow(
    location = "tr",
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20")) +
  # custom theme
  theme_minimal() +
  # update axes labels, titles
  labs(title = "Total Area Suitable for Oyster Aquaculture",
       subtitle = "by West Coast Exclusive Economic Zones (EEZs)",
       fill = bquote("Suitable Area (km"^{2}~")" ),
       x = "Longitude",
       y = "Latitude") +
  theme(plot.title.position = "plot",
        plot.title = element_text(hjust = 0.95, vjust = 1,
                                  family = "Futura",
                                  face = "bold",
                                  size = 16),
        plot.subtitle = element_text(family = "Futura",
                                     face = "plain",
                                     size = 10,
                                     vjust = 0.5),
        legend.box.margin =  margin(l = 0.5, unit = "cm"),
        legend.title = element_text(family = "Futura",
                                    hjust = -1,
                                    vjust = 0.5), # these arguments don't seem to work on longer titles...
        legend.title.align = 0.5,
        # legend.
        axis.text.x = element_text(angle = 45,
                                   vjust = 0.75,
                                   hjust = 0.9),
        axis.title.x = element_text(vjust = -0.5, family = "Futura"),
        axis.title.y = element_text(family = "Futura")
        )

# show plot
plot_1
```

## Now, let's look at the Common cuttlefish (*Sepia officinalis*)

```{r}

```
